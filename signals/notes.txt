What is a signal?
=====================================================

A signal is an event generated by the UNIX and Linux systems in response to some condition, upon receipt of which a process may in turn take some action.

Signal can be thought of as software interrupt

Who can send signals?
========================================================
----> Kernel to Process

----> Process to another Process

----> Process to itself



What happens when the process receives a signal which it is not catching?
=====================================================

------>  the process will be terminated immediately

------>  a core dump file is created.

------>   This file, called core and placed in the current directory

------>   is an image of the process that can be useful in debugging


What are the types of signals in Linux?
=====================================================

Two types:
1. Maskable
2. Non Maskable

Maskable signals or interrupts in Linux are those signals which can be changed or ignored by the user.
E.g. ctrl+c , ctrl+\

Non-Maskable signals or interrupts are those interrupts whick cannot be changed or ignored by the user. For example, Ctrl+Z.
E.g. ctrl+z

Command to find out the list of signals in Linux?
=====================================================

kill -l 

Meaning of each signals
======================================================================

SIGHUP		---->	If a process is being run from terminal and that terminal suddenly goes away then the process receives this signal. “HUP” is short for “hang up” and refers to hanging up the telephone in the days of telephone modems

SIGINT		---->   The process was “interrupted”. This happens when you press Control+C on the controlling terminal.

SIGQUIT		---->	Control+\

SIGILL		---->	Illegal instruction. The program contained some machine code the CPU can't understand.

SIGTRAP		---->	This signal is used mainly from within debuggers and program tracers

SIGABRT		---->	The program called the abort() function. This is an emergency stop

SIGBUS		---->	An attempt was made to access memory incorrectly. This can be caused by alignment errors in memory access etc. 

SIGFPE		---->	A floating point exception happened in the program. 

SIGKILL 	---->	The process was explicitly killed by somebody wielding the kill program.

SIGUSR1		---->	Left for the programmers to do whatever they want

SIGSEGV 	---->	An attempt was made to access memory not allocated to the process. This is often caused by reading off the end of arrays etc.

SIGUSR2		---->	Left for the programmers to do whatever they want.

SIGPIPE		---->	If a process is producing output that is being fed into another process that consume it via a pipe (“producer | consumer”) and the consumer dies then the producer is sent this signal.

SIGALRM		---->	A process can request a “wake up call” from the operating system at some time in the future by calling the alarm() function. When that time comes round the wake up call consists of this signal.

SIGTERM		---->	The process was explicitly killed by somebody wielding the kill program.

SIGSTKFLT	---->	Stack fault on coprocessor

SIGCHLD		---->	The process had previously created one or more child processes with the fork() function. One or more of these processes has since died.

SIGCONT		---->	(To be read in conjunction with SIGSTOP.) If a process has been paused by sending it SIGSTOP then sending SIGCONT to the process wakes it up again (“continues” it).

SIGSTOP		---->	(To be read in conjunction with SIGCONT.)If a process is sent SIGSTOP it is paused by the operating system. All its state is preserved ready for it to be restarted (by SIGCONT) but it doesn't get any more CPU cycles until then.

SIGTSTP		----> 	Essentially the same as SIGSTOP. This is the signal sent when the user hits Control+Z on the terminal. (SIGTSTP is short for “terminal stop”) The only difference between SIGTSTP and SIGSTOP is that pausing is only the default action for SIGTSTP but is the required action for SIGSTOP. The process can opt to handle SIGTSTP differently but gets no choice regarding SIGSTOP

SIGTTIN		---->	The operating system sends this signal to a backgrounded process when it tries to read input from its terminal. The typical response is to pause (as per SIGSTOP and SIFTSTP) and wait for the SIGCONT that arrives when the process is brought back to the foreground

SIGTTOU		---->	The operating system sends this signal to a backgrounded process when it tries to write output to its terminal. The typical response is as per SIGTTIN.

SIGURG		---->	The operating system sends this signal to a process using a network connection when “urgent” out of band data is sent to it.

SIGXCPU		---->	The operating system sends this signal to a process that has exceeded its CPU limit. You can cancel any CPU limit with the shell command “ulimit -t unlimited” prior to running make though it is more likely that something has gone wrong if you reach the CPU limit in make.

SIGXFSZ		----->	The operating system sends this signal to a process that has tried to create a file above the file size limit. You can cancel any file size limit with the shell command “ulimit -f unlimited” prior to running make though it is more likely that something has gone wrong if you reach the file size limit in make.

SIGVTALRM	----->	This is very similar to SIGALRM, but while SIGALRM is sent after a certain amount of real time has passed, SIGVTALRM is sent after a certain amount of time has been spent running the process.

SIGPROF		----->	This is also very similar to SIGALRM and SIGVTALRM, but while SIGALRM is sent after a certain amount of real time has passed, SIGPROF is sent after a certain amount of time has been spent running the process and running system code on behalf of the process.

SIGWINCH	----->  (Mostly unused these days.) A process used to be sent this signal when one of its windows was resized

SIGIO		----->	(Also known as SIGPOLL.) A process can arrange to have this signal sent to it when there is some input ready for it to process or an output channel	has become ready for writing.

SIGPWR		----->	A signal sent to processes by a power management service to indicate that power has switched to a short term emergency power supply. The process (especially long-running daemons) may care to shut down cleanlt before the emergency power fails

SIGSYS		----->	Unused

How to send Signals?
=====================================================
Sending signals from Keyboard:

----->  When you press CTRL+C key, a SIGINT  is sent which default action is to terminate the process

-----> When you press CTRL+\ key, a SIGQUIT is sent which default action is to terminate the process dumping core

-----> When you press CTRL+Z key, a SIGSTOP signal is sent that suspends the program


Other common method is to use the kill command 
kill -signal pid
killall -signal binary
The difference between kill and killall is that kill only sends signals to process identified by their pid, killall sends the signal to all process of a given name.

Default Actions of Signals?
==============================================================

Each signal has a default action.

---------->	Term : The process will terminate

---------->	Core : The process will terminate and produce a core dump file that traces the process state at the time of termination.

----------> Ign : The process will ignore the signal

---------->	Stop : The process will stop, like with a Ctrl-Z

----------> Cont : The process will continue from being stopped


How to handle Signals?
=======================================================

The primary system call for signal handling is signal()

int main()
{
	signal(SIGPWR, powerFailureHandler);
	.......
}


void powerFailureHandler(int signum)
{
	//Saves states to restore later
	.......
}

The first line in main() establishes a handler for the SIGPWR signals. 

Arguments:
int signal(int signum, void (*handler)(int))
first argument: signal number, such as SIGSTOP or SIGINT
second argument: a function pointer type which points to the signal handler. 


Recommended Way of setting signal actions: sigaction
===============================================================

The sigaction(2) function is a better way to set the signal action. It has the prototype:

int sigaction (int signum, const struct sigaction *act, struct sigaction *oldact);

As you can see you don't pass the pointer to the signal handler directly, but instead a struct sigaction object. It's defined as:

struct sigaction {
        void     (*sa_handler)(int);
        void     (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t   sa_mask;
        int        sa_flags;
        void     (*sa_restorer)(void);
};

sa_handler - This is the pointer to your handler function that has the same prototype as a handler for signal(2).

sa_sigaction - This is an alternative way to run the signal handler. It has two additional arguments beside the signal number where the siginfo_t * is the more interesting. 

sa_mask allows you to explicitly set signals that are blocked during the execution of the handler. In addition if you don't use the SA_NODEFER flag the signal which triggered will be also blocked.

sa_flags allow to modify the behavior of the signal handling process. For the detailed description of this field, see the manual page. To use the sa_sigaction handler you must use SA_SIGINFO flag here.

How to block signals
==========================================================

There is sometime a need to block receiving some signals, not handling them. 

Traditional way is to use the deprecated signal(2) function with SIG_IGN constant as a signal handler.

There is also newer, recommended function to do that: sigprocmask(2). 



