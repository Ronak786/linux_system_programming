
Assume that two independent processes, A and B, are appending to the same file.

Each has opened the file but without the O_APPEND flag.

Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file).

Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file)

Then B calls write, which increments B’s current file offset for the file to 1,600

Then the kernel switches processes and A resumes.

When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file.

The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it).

The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls


#include <unistd.h>

ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
/* Returns: number of bytes read, 0 if end of file, −1 on error */

ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
/* Returns: number of bytes written if OK, −1 on error */

Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.
• There is no way to interrupt the two operations that occur when we call pread.
• The current file offset is not updated.

Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions.


